Cellule.java /

public class Cellule {
    private int valeur;

    public Cellule() {
        this.valeur = 0; // Par défaut, une cellule est vide
    }

    public Cellule(int valeur) {
        if (valeur < 0 || valeur > 9) {
            throw new IllegalArgumentException("La valeur d'une cellule doit être entre 0 et 9 inclus.");
        }
        this.valeur = valeur;
    }

    public int getValeur() {
        return valeur;
    }

    public void setValeur(int valeur) {
        this.valeur = valeur;
    }

    public boolean estVide() {
        return valeur == 0;
    }

    @Override
    public String toString() {
        return Integer.toString(valeur);
    }
}

GrilleSudoku.java /

public class GrilleSudoku {
    private Cellule[][] grille;

    public GrilleSudoku() {
        grille = new Cellule[9][9];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                grille[i][j] = new Cellule();
            }
        }
    }

    public Cellule getCellule(int ligne, int colonne) {
        return grille[ligne][colonne];
    }

    public void setCellule(int ligne, int colonne, int valeur) {
        grille[ligne][colonne].setValeur(valeur);
    }

    public boolean estValide(int ligne, int colonne, int valeur) {
        // Vérifie si la valeur est déjà présente dans la même ligne
        for (int i = 0; i < 9; i++) {
            if (i != colonne && grille[ligne][i].getValeur() == valeur) {
                return false;
            }
        }

        // Vérifie si la valeur est déjà présente dans la même colonne
        for (int j = 0; j < 9; j++) {
            if (j != ligne && grille[j][colonne].getValeur() == valeur) {
                return false;
            }
        }

        // Vérifie si la valeur est déjà présente dans le même bloc 3x3
        int blocLigne = ligne / 3 * 3;
        int blocColonne = colonne / 3 * 3;
        for (int i = blocLigne; i < blocLigne + 3; i++) {
            for (int j = blocColonne; j < blocColonne + 3; j++) {
                if (grille[i][j].getValeur() == valeur) {
                    return false;
                }
            }
        }

        return true; // Retourne true si la valeur est valide
    }

    public boolean estComplet() {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (grille[i][j].estVide()) {
                    return false;
                }
            }
        }
        return true;
    }
}

Makefile /


# Nom du fichier exécutable
EXECUTABLE = Main

# Liste des fichiers .class
CLASSES = $(SOURCES:.java=.class)

# Commande pour compiler les fichiers sources en bytecode Java
COMPILE =  javac -implicit:none *.java

# Commande pour exécuter le programme
RUN = java -classpath . $(EXECUTABLE)

# Règle pour la compilation
compile:
	$(COMPILE) 

# Règle pour exécuter le programme
run:
	$(RUN)

# Règle par défaut (exécuter après 'make' sans argument)
default: compile

# Nettoyer les fichiers générés
clean:
	rm -f *.class

SudokuController.java /

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class SudokuController implements ActionListener {
    private GrilleSudoku grille;
    private SudokuInterface sudokuInterface;

    public SudokuController(GrilleSudoku grille, SudokuInterface sudokuInterface) {
        this.grille = grille;
        this.sudokuInterface = sudokuInterface;

        for (JButton[] row : sudokuInterface.getBoutons()) {
            for (JButton button : row) {
                button.addActionListener(this); // Ajout de l'action listener pour chaque bouton de la grille
            }
        }
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        JButton selectedButton = (JButton) e.getSource();

        // Récupérer les coordonnées de la case sélectionnée à partir du bouton cliqué
        int row = (int) selectedButton.getClientProperty("row");
        int col = (int) selectedButton.getClientProperty("col");

        // Demander à l'utilisateur d'entrer une valeur
        String inputValue = JOptionPane.showInputDialog("Enter a number:");
        // Vérifier si l'entrée n'est pas nulle
        if (inputValue != null && !inputValue.isEmpty()) {
            try {
                // Convertir la valeur en entier
                int value = Integer.parseInt(inputValue);
                // Mettre à jour la valeur de la cellule dans la grille
                grille.setCellule(row, col, value);
                // Mettre à jour l'affichage du bouton
                selectedButton.setText(inputValue);
            } catch (NumberFormatException ex) {
                JOptionPane.showMessageDialog(null, "Invalid number format!");
            }
        }
    }
}

SudokuFileHandler.java /

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Scanner;

public class SudokuFileHandler {
    public static GrilleSudoku chargerGrille(String cheminFichier) throws FileNotFoundException {
        GrilleSudoku grille = new GrilleSudoku();
        File fichier = new File(cheminFichier);
        Scanner scanner = new Scanner(fichier);
        
        for (int i = 0; i < 9; i++) {
            String ligne = scanner.nextLine();
            for (int j = 0; j < 9; j++) {
                int valeur = Character.getNumericValue(ligne.charAt(j));
                grille.setCellule(i, j, valeur);
            }
        }
        
        scanner.close();
        return grille;
    }

    public static void sauvegarderGrille(GrilleSudoku grille, String cheminFichier) throws FileNotFoundException {
        PrintWriter writer = new PrintWriter(cheminFichier);
        
        for (int i = 0; i < 9; i++) {
            StringBuilder ligne = new StringBuilder();
            for (int j = 0; j < 9; j++) {
                ligne.append(grille.getCellule(i, j).getValeur());
            }
            writer.println(ligne);
        }
        
        writer.close();
    }
}

SudokuFileIO.java /

import java.io.*;

public class SudokuFileIO {
    private static final String FILENAME = "sudoku.txt";

    public static void sauvegarderGrilleVide() {
        try (PrintWriter writer = new PrintWriter(new FileWriter(FILENAME))) {
            for (int ligne = 0; ligne < 9; ligne++) {
                for (int colonne = 0; colonne < 9; colonne++) {
                    writer.print("0 "); // Grille vide
                }
                writer.println();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static GrilleSudoku chargerGrilleVide() {
        GrilleSudoku grille = new GrilleSudoku();
        // Nous n'avons pas besoin de charger une grille vide car elle est déjà initialisée lors de la création
        return grille;
    }

SudokuInterface.java /

import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;

public class SudokuInterface extends JFrame {
    private GrilleSudoku grille;
    private JButton[][] boutons;
    private JButton sauvegarderButton;
    private JButton chargerButton;
    private SudokuController controller;

    public SudokuInterface(GrilleSudoku grille) {
        super("Sudoku");

        // Initialisation de la grille Sudoku avec la grille passée en argument
        this.grille = grille;

        // Création des boutons pour chaque cellule de la grille
        boutons = new JButton[9][9];
        JPanel grillePanel = new JPanel(new GridLayout(3, 3));
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                JPanel sousGrillePanel = new JPanel(new GridLayout(3, 3));
                Border border = BorderFactory.createLineBorder(Color.BLACK, 5); // Bordure de largeur 5
                sousGrillePanel.setBorder(border);
                for (int k = 0; k < 3; k++) {
                    for (int l = 0; l < 3; l++) {
                        boutons[i * 3 + k][j * 3 + l] = new JButton();
                        boutons[i * 3 + k][j * 3 + l].setFont(new Font("Arial", Font.PLAIN, 20));
                        boutons[i * 3 + k][j * 3 + l].setPreferredSize(new Dimension(50, 50));
                        boutons[i * 3 + k][j * 3 + l].setBackground(Color.WHITE); // Couleur blanche
                        // Ajout des coordonnées comme attribut du bouton
                        boutons[i * 3 + k][j * 3 + l].putClientProperty("row", i * 3 + k);
                        boutons[i * 3 + k][j * 3 + l].putClientProperty("col", j * 3 + l);

                        sousGrillePanel.add(boutons[i * 3 + k][j * 3 + l]);
                    }
                }
                grillePanel.add(sousGrillePanel);
            }
        }

        // Création des boutons pour les fonctionnalités supplémentaires
        sauvegarderButton = new JButton("Sauvegarder");
        chargerButton = new JButton("Charger");

        // Configuration de la fenêtre
        setLayout(new BorderLayout());
        add(grillePanel, BorderLayout.CENTER);
        JPanel buttonPanel = new JPanel(new GridLayout(1, 2));
        buttonPanel.add(sauvegarderButton);
        buttonPanel.add(chargerButton);
        add(buttonPanel, BorderLayout.SOUTH);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }

    public JButton[][] getBoutons() {
        return boutons;
    }

    public GrilleSudoku getGrille() {
        return grille;
    }

    public JButton getSauvegarderButton() {
        return sauvegarderButton;
    }

    public JButton getChargerButton() {
        return chargerButton;
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(SudokuInterface(grille));
    }
}

Main.java /

import javax.swing.SwingUtilities;

public class Main {
    public static void main(String[] args) {
        GrilleSudoku grille = new GrilleSudoku(); // Créez une instance de GrilleSudoku
        SwingUtilities.invokeLater(() -> new SudokuInterface(grille));
    }
}

























// Cellule.java
public class Cellule {
    private int valeur;

    public Cellule() {
        this.valeur = 0; // Par défaut, une cellule est vide
    }

    public Cellule(int valeur) {
        if (valeur < 0 || valeur > 9) {
            throw new IllegalArgumentException("La valeur d'une cellule doit être entre 0 et 9 inclus.");
        }
        this.valeur = valeur;
    }

    public int getValeur() {
        return valeur;
    }

    public void setValeur(int valeur) {
        this.valeur = valeur;
    }

    public boolean estVide() {
        return valeur == 0;
    }

    @Override
    public String toString() {
        return Integer.toString(valeur);
    }
}

// GrilleSudoku.java
public class GrilleSudoku {
    private Cellule[][] grille;

    public GrilleSudoku() {
        grille = new Cellule[9][9];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                grille[i][j] = new Cellule();
            }
        }
    }

    public Cellule getCellule(int ligne, int colonne) {
        return grille[ligne][colonne];
    }

    public void setCellule(int ligne, int colonne, int valeur) {
        grille[ligne][colonne].setValeur(valeur);
    }

    public boolean estValide(int ligne, int colonne, int valeur) {
        // Vérifie si la valeur est déjà présente dans la même ligne
        for (int i = 0; i < 9; i++) {
            if (i != colonne && grille[ligne][i].getValeur() == valeur) {
                return false;
            }
        }

        // Vérifie si la valeur est déjà présente dans la même colonne
        for (int j = 0; j < 9; j++) {
            if (j != ligne && grille[j][colonne].getValeur() == valeur) {
                return false;
            }
        }

        // Vérifie si la valeur est déjà présente dans le même bloc 3x3
        int blocLigne = ligne / 3 * 3;
        int blocColonne = colonne / 3 * 3;
        for (int i = blocLigne; i < blocLigne + 3; i++) {
            for (int j = blocColonne; j < blocColonne + 3; j++) {
                if (grille[i][j].getValeur() == valeur) {
                    return false;
                }
            }
        }

        return true; // Retourne true si la valeur est valide
    }

    public boolean estComplet() {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (grille[i][j].estVide()) {
                    return false;
                }
            }
        }
        return true;
    }
}

// SudokuController.java
import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class SudokuController implements ActionListener {
    private GrilleSudoku grille;
    private SudokuInterface sudokuInterface;

    public SudokuController(GrilleSudoku grille, SudokuInterface sudokuInterface) {
        this.grille = grille;
        this.sudokuInterface = sudokuInterface;

        for (JButton[] row : sudokuInterface.getBoutons()) {
            for (JButton button : row) {
                button.addActionListener(this); // Ajout de l'action listener pour chaque bouton de la grille
            }
        }
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        JButton selectedButton = (JButton) e.getSource();

        // Récupérer les coordonnées de la case sélectionnée à partir du bouton cliqué
        int row = (int) selectedButton.getClientProperty("row");
        int col = (int) selectedButton.getClientProperty("col");

        // Demander à l'utilisateur d'entrer une valeur
        String inputValue = JOptionPane.showInputDialog("Enter a number:");
        // Vérifier si l'entrée n'est pas nulle
        if (inputValue != null && !inputValue.isEmpty()) {
            try {
                // Convertir la valeur en entier
                int value = Integer.parseInt(inputValue);
                // Vérifier si la valeur est valide
                if (grille.estValide(row, col, value)) {
                    // Mettre à jour la valeur de la cellule dans la grille
                    grille.setCellule(row, col, value);
                    // Mettre à jour l'affichage du bouton
                    selectedButton.setText(inputValue);
                } else {
                    JOptionPane.showMessageDialog(null, "Invalid number! Please enter a valid number.");
                }
            } catch (NumberFormatException ex) {
                JOptionPane.showMessageDialog(null, "Invalid number format! Please enter a valid number.");
            }
        }
    }
}

// SudokuFileHandler.java
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Scanner;

public class SudokuFileHandler {
    public static GrilleSudoku chargerGrille(String cheminFichier) throws FileNotFoundException {
        GrilleSudoku grille = new GrilleSudoku();
        File fichier = new File(cheminFichier);
        Scanner scanner = new Scanner(fichier);

        for (int i = 0; i < 9; i++) {
            String ligne = scanner.nextLine();
            for (int j = 0; j < 9; j++) {
                int valeur = Character.getNumericValue(ligne.charAt(j));
                grille.setCellule(i, j, valeur);
            }
        }

        scanner.close();
        return grille;
    }

    public static void sauvegarderGrille(GrilleSudoku grille, String cheminFichier) throws FileNotFoundException {
        PrintWriter writer = new PrintWriter(cheminFichier);

        for (int i = 0; i < 9; i++) {
            StringBuilder ligne = new StringBuilder();
            for (int j = 0; j < 9; j++) {
                ligne.append(grille.getCellule(i, j).getValeur());
            }
            writer.println(ligne);
        }

        writer.close();
    }
}

// SudokuFileIO.java
import java.io.*;

public class SudokuFileIO {
    private static final String FILENAME = "sudoku.txt";

    public static void sauvegarderGrilleVide() {
        try (PrintWriter writer = new PrintWriter(new FileWriter(FILENAME))) {
            for (int ligne = 0; ligne < 9; ligne++) {
                for (int colonne = 0; colonne < 9; colonne++) {
                    writer.print("0"); // Grille vide
                }
                writer.println();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static GrilleSudoku chargerGrilleVide() {
        GrilleSudoku grille = new GrilleSudoku();
        // Nous n'avons pas besoin de charger une grille vide car elle est déjà initialisée lors de la création
        return grille;
    }
}

// SudokuInterface.java
import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;

public class SudokuInterface extends JFrame {
    private GrilleSudoku grille;
    private JButton[][] boutons;
    private JButton sauvegarderButton;
    private JButton chargerButton;
    private SudokuController controller;

    public SudokuInterface(GrilleSudoku grille) {
        super("Sudoku");

        // Initialisation de la grille Sudoku avec la grille passée en argument
        this.grille = grille;

        // Création des boutons pour chaque cellule de la grille
        boutons = new JButton[9][9];
        JPanel grillePanel = new JPanel(new GridLayout(3, 3));
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                JPanel sousGrillePanel = new JPanel(new GridLayout(3, 3));
                Border border = BorderFactory.createLineBorder(Color.BLACK, 5); // Bordure de largeur 5
                sousGrillePanel.setBorder(border);
                for (int k = 0; k < 3; k++) {
                    for (int l = 0; l < 3; l++) {
                        boutons[i * 3 + k][j * 3 + l] = new JButton();
                        boutons[i * 3 + k][j * 3 + l].setFont(new Font("Arial", Font.PLAIN, 20));
                        boutons[i * 3 + k][j * 3 + l].setPreferredSize(new Dimension(50, 50));
                        boutons[i * 3 + k][j * 3 + l].setBackground(Color.WHITE); // Couleur blanche
                        // Ajout des coordonnées comme attribut du bouton
                        boutons[i * 3 + k][j * 3 + l].putClientProperty("row", i * 3 + k);
                        boutons[i * 3 + k][j * 3 + l].putClientProperty("col", j * 3 + l);

                        sousGrillePanel.add(boutons[i * 3 + k][j * 3 + l]);
                    }
                }
                grillePanel.add(sousGrillePanel);
            }
        }

        // Création des boutons pour les fonctionnalités supplémentaires
        sauvegarderButton = new JButton("Sauvegarder");
        chargerButton = new JButton("Charger");

        // Configuration de la fenêtre
        setLayout(new BorderLayout());
        add(grillePanel, BorderLayout.CENTER);
        JPanel buttonPanel = new JPanel(new GridLayout(1, 2));
        buttonPanel.add(sauvegarderButton);
        buttonPanel.add(chargerButton);
        add(buttonPanel, BorderLayout.SOUTH);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        pack();
        setLocationRelativeTo(null);
        setVisible(true);

        // Création du contrôleur
        controller = new SudokuController(grille, this);
        // Ajout des action listeners aux boutons Sauvegarder et Charger
        sauvegarderButton.addActionListener(controller);
        chargerButton.addActionListener(controller);
    }

    public JButton[][] getBoutons() {
        return boutons;
    }

    public GrilleSudoku getGrille() {
        return grille;
    }

    public JButton getSauvegarderButton() {
        return sauvegarderButton;
    }

    public JButton getChargerButton() {
        return chargerButton;
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            GrilleSudoku grille = SudokuFileIO.chargerGrilleVide(); // Charger une grille vide au démarrage
            SudokuInterface sudokuInterface = new SudokuInterface(grille);
        });
    }
}

// Main.java
import javax.swing.SwingUtilities;

public class Main {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            GrilleSudoku grille = SudokuFileIO.chargerGrilleVide(); // Charger une grille vide au démarrage
            SudokuInterface sudokuInterface = new SudokuInterface(grille);
        });
    }
}
